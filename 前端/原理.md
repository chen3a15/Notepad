浏览器的核心原理是事件循环

事件循环

进程之间相互独立
一个进程至少有一个线程

主要的浏览器进程：
- 浏览器进程
    主要负责界面展示、用户交互、子进程管理
- 网络进程
    负责加载网络资源
- 渲染进程
    渲染进程启动后，会启动一个渲染主线程，主线程负责执行HTML、CSS、js。
    默认每个标签页拥有独立渲染进程（chrome在寻求新的进程管理，一个站点一个进程）

渲染主线程：
- 解析HTML
- 解析CSS
- 计算样式
- 布局
- 处理图层
- 渲染
- 执行js
- …

为何渲染进程不使用多线程处理？

渲染主线程调度：排队（消息队列 message queue）
最开始渲染主线程会进入一个无限循环（event loop/message loop），每次循环会取出消息队列第一个任务，没有任务则休眠。其他线程可以随时添加任务到消息队列末尾并唤醒渲染主线程。

异步：无法立即执行的任务
- 计时完成后执行：setTimeout、setInterval
- 通信完成后执行：XHR、fetch
- 用户操作后执行：addEventListener

如果一段js执行时间过长，渲染任务排队，会导致页面无响应

任务没有优先级，消息队列有优先级，同一类任务在一个队列，不同类任务可以分为不同队列。微队列（microtask queue）优于其他队列。

chrome消息队列：
- 微队列 优先级最高
    Promise.resolve().then(函数)
    MutationObserver